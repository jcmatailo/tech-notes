# Working Text

## Viewing Files in the Terminal
| **Command** | **Description** |
| --- | --- |
| `cat <file>` | used to list the contents of a file and expects the file name as the parameter. |
| `cat > <file>` | place the standard input into the file. |
| `head <file>` | Displays the first ten lines of the file. |
| `head -5 <file>` | Displays the first 5 lines of the file. |
| `head -n -5 <file>` | Negative Value Option. Show all but the last three lines. |
| `tail <file>` | Displays the last ten lines of the file. |
| `tail -5 <file>` | Displays the last 5 lines of the file. |
| `tail -f <file>` | To see changes to a file as they are happening. |
| `nl /etc/passwd \| tail -n +5` | Displays the contents of the /etc/passwd from line 5 to the end of the file. |

### STDIN
Standard input is information entered normally by the user via the keyboard.

### STDOUT
Standard output is the normal output of commands. STDOUT is also known as stream or channel #1. 
STDOUT can be directed to files.

### STDERR: 
Standard error is error messages generated by commands. STDERR is also know as stream or channel #2.

| **Command** | **Description** |
| --- | --- |
| `ls /fake /etc/ppp > test.txt` | Send the STDOUT output to the test.txt |
| `ls /fake /etc/ppp >> test.txt` | Preserve the contents of an existing file by appending to it. |
| `ls /fake /etc/ppp 2> error.txt` | When redirecting STDERR by placing the number 2 preceding the arrow > character. All error messages should be sent to the file error.txt |
| `ls /fake /etc/ppp &> all.txt` | Both STDOUT and STDERR can be sent to a file by using the ampersand & character in front of the arrow > character. |
| `ls /fake /etc/ppp > test.txt 2> error.txt` | STDOUT and STDERR can be sent to a different files. |
| `tr 'a-z' 'A-Z'` | Takes a set of characters and translates them into another set of characters. (stdin) |
| `tr 'a-z' 'A-Z' < example.txt` | Takes a set of characters and translates them into another set of characters. (stdin) |
| `tr 'a-z' 'A-Z' < example.txt > newExample.txt` | Takes a set of characters and translates them into another set of characters. (stdin) |


## Sorting Files or Input
| **Command** | **Description** |
| --- | --- |
| `sort <file>` | To rearrange the lines of files or input in either dictionary or numeric order. |
| `sort -t, -k2 -k1n -k3 os.csv` | The -t option specifies the field delimiter. The **-t** option will allow for another field separator to be specified as an argument. The **-k** option specifies the field number. The **-n** option is used to perform a numeric sort. The **-r** option is used to reverse sort. |


## Viewing File Statistics
| **Command** | **Description** |
| --- | --- |
| `wc <file>` | provides the number of lines, words and bytes (1 byte = 1 character in a text file) for a file. |
| `wc -l <file>` | show just the number of lines |
| `wc -w <file>` | show just the number of words |
| `wc -c <file>` | show just the number of bytes | 


## Filter File Sections
| **Command** | **Description** |
| --- | --- |
| `cut -d: -f1,5-7 mypasswd` | The cut command can extract columns of text from a file or standard input. Itâ€™s primarily used for working with delimited database files. By default, the cut command expects its input to be separated by the tab character, but the **-d** option can specify alternative delimiters such as the colon or comma. The **-f** option can specify which fields to display, either as a hyphenated range or a comma-separated list.


## Filter File Contents
| **Command** | **Description** |
| --- | --- |
| `grep <word> <file>`	| The grep command can be used to filter lines in a file or the output of another command that matches a specified pattern. |
| `grep -c <word> <file>` | The -c option provides a count of how many lines match |
| `grep -n <word> <file>` | The -n option to the grep command will display original line numbers. |
| `grep -v <word> <file>`| The -v option inverts the match, outputting all lines that do not contain the pattern. |
| `grep -i <word> <file>` | The -i option ignores the case (capitalization) distinctions. |
| `grep -w <word> <file>` | The -w option only returns lines which contain matches that form whole words. |


## Basic Regular Expressions
Regular expressions, also referred to as regex, are a collection of normal and special characters that are used to find simple or complex patterns, respectively, in files.

| **Character** | **Matches** |
| --- | --- |
| `.` | Any single character. |
| `[ ]` | A list of range of characters to match one character |
| `*` | The previous character repeated zero or more times |
| `^` | The first character in the pattern |
| `$` | The last character in th pattern |

| **Command** | **Description** |
| --- | --- |
| `grep 'r..f' red.txt` | The pattern r..f would find any line that contained the letter r followed by exactly two characters and then the letter f |
| `grep '[0-9]' profile.txt` | To find all the lines in profile.txt which have a number in them |
| `grep 're*d' red.txt` | e* would match zero or more occurrences of the letter e |
| `grep '^root' /etc/passwd` |  to find all lines in /etc/passwd that start with root use the pattern ^root` |
| `grep 'r$' alpha-first.txt` | To find the lines that end with an r in the alpha-first.txt file, use the pattern r$ |
| `grep -E *'pattern'* <file>` | is similar to grep, but can understand extended regular expressions. |